<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 transitional//EN">
<html>

<head>
<title>BIRT FAQ</title>
<link rel="stylesheet" href="../style/compose.css" type="text/css"/>
<meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1">
</head>

<body>

<p class="head">BIRT FAQ</p>
<p class="subhead">Eclipse Chart Engine</p>

<h1>General</h1>

<h2>Q: Can I use BIRT's chart engine in my own application?</h2>
<p>Yes. A primary goal of the
<a href="/ece">Eclipse Chart Engine</a> project is to provide a package that
can be used both with the BIRT reporting 
components as well as standalone.
</p>

<h1>Output Formats</h1>

<h2>Q: What output formats does the chart engine support?</h2>
<p>
Internally, the charting engine writes to device independent primitives.
This means that any output format may be plugged in by writing a device 
extension. A device refers to an implementation that translates rendering 
primitives into a specific file format. Release 1.0 will provide the
following:
 
<ul>
<li>24-bit images
<li>8-bit images
<li>SWT graphics (GC)
<li>SWING graphics (Graphics2D)
</ul>

<p>In addition, custom extensions may be written to support additional file formats.

<p>The device rendering framework is tailored to suit the needs of 
rendering a comprehensive set of graphics primitives, elaborate text 
layout (focused on typical usage of text rendering in charts), and event 
handling. The framework is optimized for performance.
</p>

<h2>Q: This sounds a lot like Draw2d in the GEF toolkit.
Why is the chart project creating "yet another API"?</h2>
<p>
An important goal for the charting engine is that it needs to work in a 
pure J2EE environment and that it be portable. Creating a dependency on 
Draw2D would in turn create a dependency on SWT and OS dependent libraries 
which doesn't work well for users who would like to deploy their reports 
on an application server. In addition, Draw2D API is very restrictive in 
that it uses ?integers? in its co-ordinate system which causes rounding 
off errors and erroneous output. The chart primitive rendering layer of 
abstraction provides a device-independent ?floating point? co-ordinate 
system for which primitive instructions are written to individual devices 
(of which, SWT is one). Since SWT (and draw2D) does not support floating 
point math in rendering arguments, approximations would have to be 
performed at several stages in chart generation and rendering resulting in 
inaccurate output.
<p>
For your reference, here's how the 'drawLine' API has been implemented 
using Draw2D's org.eclipse.draw2d.ScaledGraphics' implementation:

<pre class="code-block">public void drawLine(int x1, int y1, int x2, int y2)
{
        graphics.drawLine((int)Math.floor((double)x1 * zoom + 
fractionalX), (int)Math.floor((double)y1 * zoom + fractionalY), 
(int)Math.floor((double)x2 * zoom + fractionalX), 
(int)Math.floor((double)y2 * zoom + fractionalY));
}
</pre>

<p>where <code>fractionalX</code> and <code>fractionalY</code> define linear 
translation and 'zoom' 
defines a scaling factor but as you can see, resulting co-ordinates are 
truncated before they are plotted.
<p>
Another drawback with using pure Draw2D/SWT API is that it is limited in 
its feature set and doesn't generically support certain advanced features 
such as:
<ul>
<li>Text anti-aliasing
<li>Fractional font-metrics
<li>Primitive support for text rotation
<li>Defining custom shapes using a combination of polygons and curves
</ul>

<p>So, to summarize, the design objectives for the rendering API are twofold:

<ul>
<li>Create a clear abstraction layer between the core charting engine and 
the rendering API such that charts may be generated offscreen using high 
precision metrics and transformations and the device extensions (for 
specific output types) could translate the primitive instructions as 
appropriate. 
 
<li>Implement device/OS specific rendering toolkits as pluggable/removable 
extensions that implement our extension points allowing a great deal of 
flexibility in deployment configurations. 
</ul>

<p>This allows the charting engine to write out SWT charts within the eclipse 
environment and non-SWT charts (possibly SWING or completely bypassing a 
graphics toolkit and writing to a vector based file format e.g. SVG) 
outside of the eclipse environment.
</p>

<h2>Q: Does the chart package output SVG or PDF?</h2>
<p>
Not in release 1. However, 
you could easily write your own output format SVG, PDF.
For example, Apache's Batik provides a cost-effective mechanism for 
implementing SVG output. You could use this library within a new SVG 
device (by referring to our provided Swing device implementation) that 
implements our primitive rendering interface.
</p>

<h2>Q: What chart output formats are supported within reports?</h2>
<p>
For release 1, 
charts will be embedded as a scalar bitmapped image.
This will be enhanced in a subsequent release to embed vector charts (SVG, 
PDF, etc).
</p>

<h1>Chart Programming</h1>

<h2>Q: How can I create a line chart programmatically?</h2>
<p>
Here's how you could create a sample line chart that relies on the chart 
library model (either as source or as JARs in your environment):

<pre class="code-block">/**
 * Creates a line chart model as a reference implementation
 * 
 * @return An instance of the simulated runtime chart model (containing filled datasets)
 */
public static final Chart createSimpleLineChart()
{
    ChartWithAxes cwaBar = ChartWithAxesImpl.create();
    cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
    Plot p = cwaBar.getPlot();
    p.getClientArea().setBackground(
    	ColorDefinitionImpl.create(255, 255, 225));
    cwaBar.getTitle().getLabel().getCaption().
    	setValue("Sample Line Chart");

    Legend lg = cwaBar.getLegend();
    LineAttributes lia = lg.getOutline();
    lg.getText().getFont().setSize(16);
    lia.setStyle(LineStyle.SOLID_LITERAL);
    lg.getInsets().set(10, 5, 0, 0);
    lg.getOutline().setVisible(false);
    lg.setAnchor(Anchor.NORTH_LITERAL);

    Axis xAxisPrimary = cwaBar.getPrimaryBaseAxes()[0];
    xAxisPrimary.setType(AxisType.TEXT_LITERAL);
    xAxisPrimary.getMajorGrid().setTickStyle(TickStyle.BELOW_LITERAL);
    xAxisPrimary.getOrigin().setType(IntersectionType.VALUE_LITERAL);
    xAxisPrimary.getTitle().setVisible(false);

    Axis yAxisPrimary = cwaBar.getPrimaryOrthogonalAxis(xAxisPrimary);
    yAxisPrimary.getMajorGrid().setTickStyle(TickStyle.LEFT_LITERAL);
    yAxisPrimary.setPercent(true);

    Vector vs = new Vector();
    vs.add("one");
    vs.add("two");
    vs.add("three");

    ArrayList vn1 = new ArrayList();
    vn1.add(new Double(25));
    vn1.add(new Double(35));
    vn1.add(new Double(-45));

    TextDataSet categoryValues = TextDataSetImpl.create(vs);
    NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

    // CREATE THE CATEGORY SERIES
    Series seCategory = SeriesImpl.create();
    seCategory.setDataSet(categoryValues);

    // CREATE THE PRIMARY DATASET
    LineSeries ls = (LineSeries) LineSeriesImpl.create();
    ls.setSeriesIdentifier("My Line Series");
    ls.setDataSet(orthoValues1);
    ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
    ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
    ls.getLabel().setVisible(true);

    SeriesDefinition sdX = SeriesDefinitionImpl.create();
    sdX.getSeriesPalette().update(0); // SET THE COLORS IN THE PALETTE
    xAxisPrimary.getSeriesDefinitions().add(sdX);

    SeriesDefinition sdY = SeriesDefinitionImpl.create();
    sdY.getSeriesPalette().update(1); // SET THE COLORS IN THE PALETTE
    yAxisPrimary.getSeriesDefinitions().add(sdY);

    sdX.getSeries().add(seCategory);
    sdY.getSeries().add(ls);

    return cwaBar;
}
</pre>

<h2>Q: Can I add call backs when the user clicks or hovers 
over nodes in the chart?</h2>
<p>Yes ... you may add 'triggers' for various 'conditions' in the 
design-time chart model associated with 'series' or 'blocks' as follows:

<pre class="code-block">PieSeries sePie = ...;

sePie.getTriggers().add(
   TriggerImpl.create(
      TriggerCondition.MOUSE_CLICK_LITERAL,
      ActionImpl.create(
         ActionType.URL_REDIRECT_LITERAL,
         URLValueImpl.create(
            "http://www.actuate.com", null, "city", "population", null
         )
      )
   )
);
</pre>

<p>This trigger causes a URL redirect notification when a user clicks on a 
slice in a pie chart. However, this has only been implemented for the 
swing device renderer.
<p>
A reference implementation of handling user interaction has been provided 
in org.eclipse.birt.chart.device.swing.SwingRendererImpl in the following 
parts of the class:

<pre class="code-block">variables: _iun, _eh, _lhmAllTriggers
method: enableInteraction
</pre>

<p>This method creates a low-level 'ShapedAction' for a polygon, an arc or an 
oval and places it into the linked hashmap of all triggers. 
<p>
Later, when rendered, the SwingEventHandler class listens for AWT events 
on these shaped objects and notifies the class defined that implements 
IUpdateNotifier to update itself due to user interaction at view time. The 
update notifier (depending on the context) should be capable of:

<ul>
<li>Regenerating the chart (for the design-time model)
<li>Repainting the chart (for the existing generated instance)
</ul>

<p>This hasn't yet been implemented for SWT but should be easily doable.
</p>

<h2>Q: How do I put the x-axis on the bottom of the chart instead 
of the middle?</h2>
<p>
Yes, you may place the X-axis at the bottom using the following API:

<pre class="code-block">xAxis.getOrigin().setType(IntersectionType.MIN_LITERAL);
</pre>

<p>where MIN indicates 'the minimum vertical position of the plot 
(bottom)' when applied to the X axis or 'the minimal horizontal position 
of the plot (left)' when applied to the Y axis'.
</p>

<h2>Q: How do I remove the title from the legend?</h2>
<p>
Yes, set 'block' visibility for the 'TitleBlock' and the 
'Legend'.
</p>

<h2>
Q: How do I turn of the debug messages?</h2>

<p>
Running the Chart package may produce messages such as:</p>

<pre class="code-block">INFO]: SWT Display Server: win32 v3062
[INFO]: Using graphics context org.eclipse.swt.graphics.GC@GC {1023479146}
[INFO]: (STANDALONE-ENV) Creating series renderer
org.eclipse.birt.chart.render.Line
&nbsp;</pre>

<p>
To turn these off, set the logging verbose level using:

<pre class="code-block">org.eclipse.birt.chart.log.DefaultLoggerImpl.instance( )
	.setVerboseLevel( ILogger.ERROR | ILogger.WARNING | ILogger.FATAL );
</pre>
<p>
This will suppress the detailed INFORMATION messages.

<h1>
Eclipse, SWT and RCP</h1>

<h2>
Q: How do I show a chart in my Eclipse RCP application?</h2>

<p>
You could create a plug-in with a ViewPart extension that creates an SWT <br>
canvas and notifies a PaintListener implementation where the chart <br>
rendering code may be written.</p>

<p>
To render an SWT chart on a Canvas GC, see below.</p>

<h2>
Q: How can I use charts in SWT?</h2>

<p>
Here's the program François-Xavier Le Louarn wrote using the example code above 
(slightly modified, as the Axis interface does not contain the 
getSeriesDefinitions() method but AxisImpl does). He adapted the code from the 
org.eclipse.birt.chart.ui.swt.ChartModelAdapter object.</p>

<p>
The Chart project lead comments: Here's a suggestion on optimizing the number of 
calls you make to re-build the chart:<br>
<br>
Instead of building and rendering the chart in the paintControl(...) method, you 
could choose to build it off screen and render it any number of times without 
re-building it. There is no requirement that a UI component needs to be showing 
to be able to build a chart. Hence it is not mandatory to build the chart in the 
paintControl(…) method. However, if you choose to resize the client area, then 
you'd want to rebuild it for the new dimensions before you render the chart. So, 
in effect, you would want to compute the line chart off screen when the client 
area is resized ONLY rather than for every paint notification. Remember ... the 
bounds (specified in points) with which you render the chart must equate to the 
bounds used in building the chart.</p>

<pre class="code-block"><!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>

<h1>
Deployment</h1>

<h2>
Q: What JARs are needed on the class path to deploy the BIRT charting package in 
an SWT/JFace application?</h2>

<p>
If you are using 1.0M2, the following JARs need to be included in your CLASSPATH 
at build/run time:</p>

<p>
Chart engine libraries:</p>

<ul>
  <li>

<pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>engine.jar OR chart-engine.jar (from org.eclipse.birt.chart.engine)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>shared.jar OR chart-shared.jar (from org.eclipse.birt.chart.shared) (See 
  below)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>engine-extension.jar (from org.eclipse.birt.chart.engine.extension)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>device-extension.jar (from org.eclipse.birt.chart.device.extension)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>core.jar (from org.eclipse.birt.core)</li>
</ul>
<p>
3rd party dependencies:</p>

<ul>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>js.jar (Rhino 1.5R5 from org.eclipse.birt.core/lib that allows scripting)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>common.jar (from org.eclipse.emf.common/runtime)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>common.resources.jar</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>ecore.jar (from org.eclipse.emf.ecore/runtime)</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>ecore.resources.jar</li>
  <li><pre class="code-block>
<!--StartFragment -->
public class TestLineChart
{
     private static final class MyPaintListener implements PaintListener
     {
         public void paintControl(PaintEvent e)
         {
             // let's get a SWT device renderer
             IDeviceRenderer deviceRenderer = null;
             try
             {
                 System.setProperty("STANDALONE", "true");
                 deviceRenderer = PluginSettings.instance()
			.getDevice("dv.SWT");
             }
             catch (PluginException ex)
             {
                 System.err.println(
			"Oops, can't find the device renderer.");
                 ex.printStackTrace();
                 System.exit(1);
             }
             deviceRenderer
	    	.setProperty(IDeviceRenderer.GRAPHICS_CONTEXT, e.gc);

             // now let's make sure we stay in the client area's bounds
             Rectangle rect = ((Composite) e.widget).getClientArea();
             final Bounds bounds = BoundsImpl.create(rect.x + 2,
                     rect.y + 2,
                     rect.width - 4,
                     rect.height - 4);
             bounds.scale(72d /
	    	deviceRenderer.getDisplayServer().getDpiResolution());

             // create Rohit's chart
             Chart chart = createSimpleLineChart();

             // and finally, generate it...
             final Generator gr = Generator.instance();
             GeneratedChartState state;
             try
             {
                 state = gr.build(deviceRenderer.getDisplayServer(),
                         chart,
                         (Scriptable) null,
                         bounds,
                         Locale.getDefault());
                 gr.render(deviceRenderer, state);
             }
             catch (Exception ex)
             {
                 ex.printStackTrace();
                 System.exit(1);
             }
         }
     }

     public static void main(String[] args)
     {
         Display display = new Display();
         Shell shell = new Shell(display);
         shell.setLayout(new FillLayout());
         shell.setText("TestLineChart");
         Canvas canvas = new Canvas(shell, SWT.NONE);
         canvas.addPaintListener(new MyPaintListener());
         shell.setSize(400, 400);

         shell.open();
         while (!shell.isDisposed())
         {
             if (!display.readAndDispatch()) display.sleep();
         }
         display.dispose();
     }

     /**
      * Creates a line chart model as a reference implementation *
      *
      * @return An instance of the simulated runtime chart model
      * (containing filled datasets)
      */
     public static final Chart createSimpleLineChart()
     {
         ChartWithAxes cwaBar = ChartWithAxesImpl.create();
         cwaBar.getBlock().setBackground(ColorDefinitionImpl.WHITE());
         Plot p = cwaBar.getPlot();
         p.getClientArea().setBackground(ColorDefinitionImpl.create(255,
                 255,
                 225));
         cwaBar.getTitle().getLabel().getCaption()
		.setValue("Sample Line Chart");

         Legend lg = cwaBar.getLegend();
         LineAttributes lia = lg.getOutline();
         lg.getText().getFont().setSize(16);
         lia.setStyle(LineStyle.SOLID_LITERAL);
         lg.getInsets().set(10, 5, 0, 0);
         lg.getOutline().setVisible(false);
         lg.setAnchor(Anchor.NORTH_LITERAL);

         AxisImpl xAxisPrimary =
		(AxisImpl) cwaBar.getPrimaryBaseAxes()[0];
         xAxisPrimary.setType(AxisType.TEXT_LITERAL);
         xAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.BELOW_LITERAL);
         xAxisPrimary.getOrigin()
		.setType(IntersectionType.VALUE_LITERAL);
         xAxisPrimary.getTitle().setVisible(false);

         AxisImpl yAxisPrimary = (AxisImpl) cwaBar
                 .getPrimaryOrthogonalAxis(xAxisPrimary);
         yAxisPrimary.getMajorGrid()
		.setTickStyle(TickStyle.LEFT_LITERAL);
         yAxisPrimary.setPercent(true);

         Vector vs = new Vector();
         vs.add("one");
         vs.add("two");
         vs.add("three");

         ArrayList vn1 = new ArrayList();
         vn1.add(new Double(25));
         vn1.add(new Double(35));
         vn1.add(new Double(-45));

         TextDataSet categoryValues = TextDataSetImpl.create(vs);
         NumberDataSet orthoValues1 = NumberDataSetImpl.create(vn1);

         // CREATE THE CATEGORY SERIES
         Series seCategory = SeriesImpl.create();
         seCategory.setDataSet(categoryValues);

         // CREATE THE PRIMARY DATASET
         LineSeries ls = (LineSeries) LineSeriesImpl.create();
         ls.setSeriesIdentifier("My Line Series");
         ls.setDataSet(orthoValues1);
         ls.getLineAttributes().setColor(ColorDefinitionImpl.CREAM());
         ls.getMarker().setType(MarkerType.TRIANGLE_LITERAL);
         ls.getLabel().setVisible(true);

         SeriesDefinition sdX = SeriesDefinitionImpl.create();
         sdX.getSeriesPalette().update(0);
         xAxisPrimary.getSeriesDefinitions().add(sdX);

         SeriesDefinition sdY = SeriesDefinitionImpl.create();
         sdY.getSeriesPalette().update(1);
         yAxisPrimary.getSeriesDefinitions().add(sdY);

         sdX.getSeries().add(seCategory);
         sdY.getSeries().add(ls);

         return cwaBar;
     }
}</pre>ecore.xmi.jar</li>
</ul>
<p>
Also, when you run your SWT application, remember to set a system property 
called 'STANDALONE'. <p>
Note: chart-shared.jar OR shared.jar will not be needed (nor included) in the 
final release 1.0.<br>
&nbsp;</p>

</pre></pre></pre></body>
</html>